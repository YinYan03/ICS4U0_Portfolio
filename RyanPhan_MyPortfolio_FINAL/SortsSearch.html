<!DOCTYPE html>
<html>
<head>
    <link rel="stylesheet" type="text/css" href="PageStyle.css">
    <script src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_prettify.js?lang=css&lang=java&autorun=(true)"></script>
	<link href="https://fonts.googleapis.com/css?family=Open+Sans:400,600|Source+Code+Pro" rel="stylesheet">
    <title>Ryan Phan - Tutorials</title>
</head>

<div class="topNavBar">
    <div class="name">
        <a href="RyanPhan_MyPortfolio.html">Ryan Phan</a>
    </div>
    <a href="Bibliography.html">Bibliography</a>
    <a class="active" href="Tutorials.html">Tutorials</a>
    <a href="ISP.html">Distraction Action</a>
    <a href="Work.html">Work</a>
    <a href="Biography.html">Biography</a>
</div>

<body>
<h1>Sorting and Searching</h1>

<h3>Sorting Algorithms</h3>

<h2>Sequential/Linear Search</h2>

<p>
    Selection sort breaks the array down into two separate portions: a sorted and an unsorted portion.
    To do so, the sort finds the smallest element in the array and switches it with the first
    element of the list. Now we can say that the first element is sorted with respect to itself,
    making it our sorted array. Now we run through the array again, but this time skipping our first
    sorted array to find the second smallest element. Once found, we put this element at the beginning
    of the array. Now our sorted list has two elements. Now the sort skips the first two elements to find
    the third element. This process continues until the sort reaches the end of the array or
    n - 1 passes, where in is our array length. Thus it takes the same amount of time to sort an array no
	matter the order of the elements.
Here's a visual summary: <br>
    (image taken from https://www.hackerearth.com/practice/algorithms/sorting/selection-sort/tutorial/):
    <img class = "center"  src="SelectionSort.png" height="1000" width="1000" >

<p>
As you can see on the right side of the image, the sorted array increases with every pass.
    In the following example, we'll sort an array of names. Here we can demonstrate the
    <code>.compareTo()</code> method which compares two strings lexicographically (alphabetically).

<pre class="prettyprint">
/**
 * This program demonstrates selection sort.
 */
public class SelectionSortExample
{
    // Sorts an array of names using insertion sort.
    public static void selectionSort (String[] names)
    {
        /*
         * Initializes a variable called unsortedString that will store each unsorted String for
         * comparing and temporary storage purposes.
         */
        String unsortedString;

        /*
         * Shifts the starting point of the check with each pass (This is the
         * beginning of the unsorted array.)
         */
        for (int i = 0 ; i < names.length - 1 ; i++)
        {
            // Find the smallest element in unsorted array
            int smallestIndex = i;

            /*
             * Checks the unsorted String array for a lexicographically(alphabetical) lower word.
             * Once found the smallestIndex is set to that value.
             */
            for (int x = i + 1 ; x < names.length ; x++)
            {
                if (names [x].compareTo (names [smallestIndex]) < 0)
                    smallestIndex = x;
            }
            /*
             * Swaps the minimum element with the first element of the unsorted array.
             */
            String tmp = names [smallestIndex];
            names [smallestIndex] = names [i];
            names [i] = tmp;
        }

        // Prints all of the (now sorted) elements of the array.
        for (int y = 0 ; y < names.length ; y++)
        {
            System.out.print (names [y] + " ");
        }
        // Adds a line break.
        System.out.println ();
    }


    public static void main (String[] args)
    {
        String[] names = new String[]{"Andy", "Andrey", "Jefferson", "Jason", "Meghan"};
        selectionSort (names);
        System.out.println ();
    }
}
</pre>
</p>
<p>Outputs:
<table>
    <td>
        <pre>
    Andrey Andy Jason Jefferson Meghan
        </pre>
    </td>
</table>

<h2>Insertion Sort</h2>

<p>
    Similar to selection sort, insertion sort splits the array into two sections. However,
    instead of checking the entire subarray of unsorted elements, insertion sort simply sorts
    the unsorted array in the sorted array one by one. In order to do so, we'll also need
    code to shift elements down to make a slot for the element if needed.
    The sorted portion would initially consist of the first element of the array,
    then more elements would be added into the sorted portion one at a time.
    As these elements are being added to the sorted portion,
    they are inserted into their correct position by shifting elements down the array.
    In most cases, insertion sort is inefficient for large arrays.
    Insertion sort is best used when the array is nearly sorted,
    or when dealing with a small data set. For our example, we'll sort an int array this
    time.<br>

    Here's an image to help visualize insertion sort: <br>
    (image taken from https://www.geeksforgeeks.org/recursive-insertion-sort/):
<img class = "center" src="InsertionSort.png" height="500" width="500" >

<pre class="prettyprint">
/**
 * This program demonstrates insertion sort.
 */
public class InsertionSortExample
{
    // Sorts an array of ints using insertion sort.
    public static void insertionSort (int[] nums)
    {
        /*
         * Initializes a variable called unsortedInt that will store each unsorted int for
         * comparing and temporary storage purposes.
         */
        int unsortedInt;

        // Traverses the unsorted elements of the array.
        for (int x = 1; x < nums.length; x++)
        {
            // Sets unsortedInt and the index of the sorted int that it is being compared to.
            unsortedInt = nums[x];
            int sortedIntIndex = x - 1;

             /*
              * Checks if the sorted int index is pointing at a valid index and checks if the
              * element in the index is greater than the unsorted element.
              * If both conditions are satisfied, the sorted int will be copied one element
              * up in the array and the sortedIntIndex will point one index down.
              */
            while (sortedIntIndex >= 0 && nums [sortedIntIndex] >= unsortedInt)
            {
                nums [sortedIntIndex + 1] = nums [sortedIntIndex];
                sortedIntIndex--;
            }
            /*
             * Places the unsortedInt into the index above the sorted int index.
             * This will occur either when the sorted int index is pointing at -1
             * or at an int that is less than the unsorted int.
             */
            nums [sortedIntIndex + 1] = unsortedInt;
        }
        // Prints all of the (now sorted) elements of the array.
        for (int y = 0; y < nums.length; y++)
        {
            System.out.print (nums[y] + " ");
        }
        // Adds a line break.
        System.out.println ();
    }

    public static void main (String[] args)
    {
        int[] ages = new int []{5, 6, 4, -3, 9, 3, -7};
        insertionSort (ages);
        System.out.println ();
    }
}
</pre>
</p>

<p>Outputs:</p>
<table>
    <td>
        <pre>
    -7 -3 3 4 5 6 9
        </pre>
    </td>
</table>


<h3>Searching Algorithms</h3>
<h2>Sequential/Linear Search</h2>

<p>
    Let's say your searching for a package in a row of mailboxes. You can't see inside them,
    so you need to check each mail box, one after another in hopes of finding you package.
    Linear or sequential search works in much the same way. It checks each element of
    the list until it either finds the "package" or the correct element, or it reaches the
    end of the list. <br><br>

    See here:<br>
    (image taken from https://www.geeksforgeeks.org/linear-search/):
    <img class = "center"  src="Linear-Search.png" height="10000" width="10000" >

<p>
    The code for a sequential search only consists of a simple for loop and a if statement,
    done as follows:
    <pre class = "prettyprint">
public static int linearSearch (int arr[], int key)
{
    for (int x = 0 ; x < arr.length ; x++) // Loops through the whole array
    {
        if (arr [i] == key) // Checks if the element matches key
            return x;       // Return that elements index
    }
    return -1;              // Return -1 if not found
}
</pre>
</p>

<h2>Binary Search</h2>

<p>
    Binary Search is faster than sequential search, however, it requires the array to be sorted prior to its 
use. For this sort, it finds the middle element of the array, and checks if it is greater than or less than
the target element. If the middle element is the target the sort stops. If not, it checks either the elements to the left 
of the middle element if the middle element is greater than the key, otherwise it checks the right side. Repeat until the element 
is found. This is done assuming the array is sorted in ascending order.<br><br>

    See here:<br>
    (image taken from https://www.geeksforgeeks.org/binary-search/):
    <img class = "center" src="Binary-Search.png" height="1000" width="1000" >

<p>
    The code for a binary search only consists of a simple for loop and a if statement,
    done as follows:
<pre class = "prettyprint">
/* 
 * This code is contributed by Rajat Mishra 
 * taken from https://www.geeksforgeeks.org/binary-search/
 */
 
public static int binarySearch(int arr[], int x) 
    { 
        int l = 0, r = arr.length - 1; 
        while (l <= r) { 
            int m = l + (r - l) / 2; 
  
            // Check if x is present at mid 
            if (arr[m] == x) 
                return m; 
  
            // If x greater, ignore left half 
            if (arr[m] < x) 
                l = m + 1; 
  
            // If x is smaller, ignore right half 
            else
                r = m - 1; 
        } 
  
        // if we reach here, then element was 
        // not present 
        return -1; 
    } 
}
</pre>
</p>

<a href="Recursion.html"><img class = "next_page" src="NextPage.png" height="200" width="200"></a>
<a href="ArraysArrayList.html"><img class = "last_page" src="LastPage.png" height="200" width="200"></a>
</body>
</html>